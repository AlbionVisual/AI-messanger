# MySQL cheetsheet

## Содержание

1. [Команды MySQL Shell](#команды-mysql-shell)
2. [Как исползовать наш модуль python database.py](#как-исползовать-наш-модуль-python-databasepy)
3. [Языки SQL для работы с таблицами и запросами](#языки-sql-для-работы-с-таблицами-и-запросами)
   - [SQL](#sql)
   - [DDL](#ddl)
   - [DML](#dml)
4. [Библиотека Python для работы с базами данных MySQL](#библиотека-python-для-работы-с-базами-данных-mysql)
   - [Объект Соединения (Connection Object)](#объект-соединения-connection-object)
   - [Объект Курсора (Cursor Object)](#объект-курсора-cursor-object)
   - [Параметризованные запросы](#параметризованные-запросы)
   - [Обработка ошибок](#обработка-ошибок)
   - [Управление ресурсами (закрытие соединений)](#управление-ресурсами-закрытие-соединений)
   - [python-dotenv](#python-dotenv)
5. [Настройка окружения](#настройка-окружения)
   - [Установка MySQL Server](#установка-mysql-server)
   - [Создание базы данных и таблиц](#создание-базы-данных-и-таблиц)
   - [Проверка структуры и данных](#проверка-структуры-и-данных)
   - [Подключение Python к MySQL (кратко)](#подключение-python-к-mysql-кратко)
6. [Подробнее про MySQL - что это за зверь?](#подробнее-про-mysql---что-это-за-зверь)
   - [Основные концепции MySQL](#основные-концепции-mysql)
7. [Подробнее про библиотеку на python](#подробнее-про-библиотеку-на-python)
   - [Как писать функции на ней](#как-писать-функции-на-ней)
   - [Процесс взаимодействия](#процесс-взаимодействия)
   - [Сам драйвер mysql-connector-python](#сам-драйвер-mysql-connector-python)

## Команды `MySQL Shell`

### Основный команды для просмотра ситуации

### Попробовать SQL

У нас уже всё должно быть создано, поэтому перейдём к использованию:

- Выберем базу данных, которую хотим сейчас использовать:
  ```SQL
  USE ai_chat_db
  ```
- Посмотрим на таблицы, которые у нас сейчас есть:
  ```SQL
  SHOW TABLES
  ```
- Посмотрим как выглядит одна из таблиц:
  ```SQL
  DESCRIBE conversations
  ```
- Чтобы посмотреть какие записи (строки) есть в базе данных воспользуемься запросом:
  ```SQL
  SELECT * FROM conversations
  ```
- Добавим несколько строк (каждое исполнение команды добавляет строку и не отменяет действия предыдущей команды):
  ```SQL
  INSERT INTO conversations (title) VALUES ('Второй диалог')
  ```
  Теперь можем вернуться к просмотру строк таблицы командой выше, новые поля должны появится
- Теперь попытаемся удалить строки:
  ```SQL
  DELETE FROM conversations WHERE created_at > '2025-02-07'
  ```

## Как исползовать наш модуль `python database.py`

## Языки `SQL` для работы с таблицами и запросами

### SQL

**SQL (Structured Query Language)** - это стандартный язык для управления реляционными базами данных. Он делится на несколько подмножеств:

1. **DDL (Data Definition Language)** - Язык определения данных. Используется для создания, изменения и удаления структуры базы данных и ее объектов.
2. **DML (Data Manipulation Language)** - Язык манипуляции данными. Используется для вставки, получения, изменения и удаления данных в таблицах

### DDL

- **`CREATE DATABASE database_name;`**: Создает новую базу данных.
  ```SQL
  CREATE DATABASE ai_chat_db;
  ```
  **Наше использование:** Используется один раз при первоначальной настройке проекта для создания `ai_chat_db`.
- **`USE database_name;`**: Выбирает базу данных для работы.
  ```sql
  USE ai_chat_db;
  ```
  **Наше использование:** Используется в MySQL Shell после создания БД, чтобы все последующие команды `CREATE TABLE` применялись к ней. В Python это не нужно, так как имя БД указывается при подключении.
- **`CREATE TABLE table_name (...);`**: Создает новую таблицу с указанными столбцами и их свойствами.

  ```sql
  CREATE TABLE conversations (
      id INT AUTO_INCREMENT PRIMARY KEY, -- Целое число, автоинкремент, первичный ключ
      title VARCHAR(255) NOT NULL DEFAULT 'Новый диалог', -- Текст до 255 символов, не может быть пустым, значение по умолчанию
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Дата/время создания, по умолчанию текущее время
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- Дата/время обновления, обновляется при изменении строки
  );

  CREATE TABLE messages (
      id INT AUTO_INCREMENT PRIMARY KEY,
      conversation_id INT NOT NULL, -- Внешний ключ, ссылается на conversations.id
      sender ENUM('user', 'ai') NOT NULL, -- Перечисление, может быть 'user' или 'ai'
      content TEXT NOT NULL, -- Длинный текст
      timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE -- При удалении диалога, удаляются и все связанные сообщения
  );
  ```

  **Наше использование:** Используется один раз для создания таблиц `conversations` и `messages`, которые будут хранить диалоги и их сообщения.

  - **Типы данных:**
    - `INT`: Целые числа (для `id`, `conversation_id`).
    - `VARCHAR(length)`: Строки переменной длины (для `title`). `255` - максимальная длина.
    - `TEXT`: Длинные текстовые строки (для `content` сообщений).
    - `TIMESTAMP`: Дата и время. `DEFAULT CURRENT_TIMESTAMP` устанавливает текущее время при создании записи. `ON UPDATE CURRENT_TIMESTAMP` обновляет время при изменении записи.
    - `ENUM('val1', 'val2')`: Перечисление, столбец может принимать только одно из указанных значений (для `sender`).
  - **Ограничения:**
    - `PRIMARY KEY`: Уникальный идентификатор строки, не может быть `NULL`.
    - `AUTO_INCREMENT`: Автоматически увеличивает значение для `PRIMARY KEY` при каждой новой вставке.
    - `NOT NULL`: Столбец не может содержать `NULL` значения.
    - `DEFAULT value`: Устанавливает значение по умолчанию, если оно не указано при вставке.

- **`ALTER TABLE table_name ADD COLUMN column_name data_type;`**: Изменяет структуру существующей таблицы (добавляет/удаляет столбцы, индексы и т.д.).
  ```sql
  ALTER TABLE conversations ADD COLUMN is_archived BOOLEAN DEFAULT FALSE;
  ```
  **Наше использование:** Может понадобиться в будущем для добавления новых полей к диалогам или сообщениям (например, флаг архивации, теги).
- **`DROP TABLE table_name;`**: Удаляет таблицу из базы данных.
  ```sql
  DROP TABLE messages;
  ```
  **Наше использование:** Используется редко, в основном для очистки тестовых данных или при серьезных изменениях схемы на этапе разработки.
- **`DROP DATABASE database_name;`**: Удаляет базу данных.
  ```sql
  DROP DATABASE ai_chat_db;
  ```
  **Наше использование:** Используется для полного сброса локальной БД.

### DML

- **`INSERT INTO table_name (column1, column2) VALUES (value1, value2);`**: Вставляет новые строки данных в таблицу.
  ```sql
  INSERT INTO conversations (title) VALUES ('Первый диалог');
  INSERT INTO messages (conversation_id, sender, content) VALUES (1, 'user', 'Привет, AI!');
  ```
  **Наше использование:** Основная команда для сохранения новых диалогов и каждого сообщения (как пользователя, так и AI) в базе данных.
- **`SELECT column1, column2 FROM table_name WHERE condition ORDER BY column LIMIT count;`**: Извлекает данные из одной или нескольких таблиц. Это самая часто используемая команда.
  - **`FROM`**: Указывает таблицу, из которой извлекаются данные.
  - **`WHERE`**: Фильтрует строки по определенным условиям.
  - **`ORDER BY`**: Сортирует результаты.
  - **`LIMIT`**: Ограничивает количество возвращаемых строк.
  - **`JOIN`**: Объединяет строки из двух или более таблиц на основе связанных столбцов.
  ```sql
  SELECT * FROM conversations; -- Выбрать все столбцы из таблицы conversations
  SELECT title FROM conversations WHERE id = 1; -- Выбрать заголовок диалога с ID 1
  SELECT content, sender FROM messages WHERE conversation_id = 1 ORDER BY timestamp ASC; -- Сообщения для диалога 1, отсортированные по времени
  ```
  **Наше использование:**
  - Получение списка всех диалогов для отображения в боковой панели.
  - Получение всех сообщений для конкретного диалога, чтобы отобразить историю чата.
  - Будет использоваться для реализации функции поиска по диалогам/сообщениям.
- **`UPDATE table_name SET column1 = value1 WHERE condition;`**: Изменяет существующие данные в таблице.
  ```sql
  UPDATE conversations SET title = 'Мой первый диалог' WHERE id = 1;
  ```
  **Наше использование:** Изменение заголовков диалогов, обновление статусов (например, `is_archived`).
- **`DELETE FROM table_name WHERE condition;`**: Удаляет строки данных из таблицы.
  ```sql
  DELETE FROM messages WHERE conversation_id = 1 AND sender = 'user';
  DELETE FROM conversations WHERE id = 1;
  ```
  **Наше использование:** Удаление отдельных диалогов или сообщений. Благодаря `ON DELETE CASCADE` в таблице `messages`, удаление диалога автоматически удалит все его сообщения.

## Библиотека `Python` для работы с базами данных `MySQL`

### Объект Соединения (Connection Object)

- **Что это:** Представляет собой активное сетевое соединение между вашим Python-приложением и MySQL-сервером. Создается функцией `mysql.connector.connect()`.
- **Пример создания:**
  ```python
  import mysql.connector
  # ... параметры подключения ...
  conn = mysql.connector.connect(host=..., user=..., password=..., database=...)
  ```
- **Возможности:**
  - **`conn.commit()`:** Сохраняет все изменения, сделанные в рамках текущей транзакции (набор `INSERT`, `UPDATE`, `DELETE` операций). **Крайне важно вызывать `commit()` после любых изменений данных, иначе они не будут сохранены в БД.**
    ```python
    conn.commit()
    ```
  - **`conn.rollback()`:** Отменяет все изменения, сделанные в рамках текущей транзакции. Используется, если что-то пошло не так.
    ```python
    conn.rollback()
    ```
  - **`conn.close()`:** Закрывает соединение с базой данных. Освобождает ресурсы на сервере.
    ```python
    conn.close()
    ```
- **Наше использование:** Каждая функция, работающая с БД, будет получать или создавать такой объект.

### Объект Курсора (Cursor Object)

- **Что это:** Объект, полученный из объекта соединения (`conn.cursor()`), который используется для выполнения SQL-запросов. Думайте о нем как о "указателе" или "инструменте" для работы с данными.
- **Пример создания:**
  ```python
  # Предполагается, что conn - это активное соединение
  cursor = conn.cursor()
  # Для получения результатов в виде словарей:
  cursor_dict = conn.cursor(dictionary=True)
  ```
- **Возможности:**
  - **`cursor.execute(sql_query, params=None)`:** Выполняет SQL-запрос. `params` — это кортеж или словарь значений для параметризованного запроса.
    ```python
    cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
    ```
  - **`cursor.fetchone()`:** Извлекает одну следующую строку из набора результатов `SELECT` запроса.
    ```python
    row = cursor.fetchone()
    ```
  - **`cursor.fetchall()`:** Извлекает все оставшиеся строки из набора результатов `SELECT` запроса.
    ```python
    all_rows = cursor.fetchall()
    ```
  - **`cursor.lastrowid`:** После `INSERT` запроса возвращает ID последней вставленной строки, если столбец является `AUTO_INCREMENT`.
    ```python
    new_id = cursor.lastrowid
    ```
  - **`cursor.rowcount`:** Возвращает количество строк, затронутых последним `INSERT`, `UPDATE` или `DELETE` запросом.
    ```python
    rows_affected = cursor.rowcount
    ```
  - **`cursor.close()`:** Закрывает курсор.
    ```python
    cursor.close()
    ```
- **Наше использование:** Основной инструмент для выполнения всех SQL-операций.

### Параметризованные запросы

- **Что это:** Метод выполнения SQL-запросов, при котором SQL-команда и данные передаются отдельно. В SQL-команде используются плейсхолдеры (`%s` для `mysql-connector-python`), а фактические значения передаются вторым аргументом в `cursor.execute()`.
- **Почему это важно:** **Предотвращает SQL-инъекции.** Если вы вставляете данные, полученные от пользователя, напрямую в SQL-строку, злоумышленник может внедрить вредоносный SQL-код. Параметризованные запросы гарантируют, что данные всегда обрабатываются как данные, а не как часть SQL-команды.
- **Пример:**

  ```python
  user_input_name = "O'Reilly" # Злонамеренный ввод или просто имя с апострофом
  user_input_email = "test@example.com"

  # НЕПРАВИЛЬНО (уязвимо к SQL-инъекциям):
  # sql = f"INSERT INTO users (name, email) VALUES ('{user_input_name}', '{user_input_email}')"
  # cursor.execute(sql)

  # ПРАВИЛЬНО (параметризованный запрос):
  sql = "INSERT INTO users (name, email) VALUES (%s, %s)"
  cursor.execute(sql, (user_input_name, user_input_email))
  ```

- **Наше использование:** Всегда используйте параметризованные запросы при вставке или обновлении данных, полученных от фронтенда (например, текст сообщения, заголовок диалога).

### Обработка ошибок

- **Что это:** Использование блоков `try-except` для перехвата исключений, которые могут возникнуть при работе с базой данных (например, потеря соединения, синтаксическая ошибка в SQL, нарушение ограничений).
- **Пример:**
  ```python
  try:
      # ... код, который может вызвать ошибку БД ...
      cursor.execute("INSERT INTO non_existent_table (col) VALUES (%s)", ("val",))
      conn.commit()
  except mysql.connector.Error as err:
      print(f"Произошла ошибка базы данных: {err}")
      conn.rollback() # Откат изменений
      # Можно записать ошибку в лог, вернуть None и т.д.
  ```
- **Наше использование:** В каждой функции вашего `database.py` должен быть `try-except mysql.connector.Error` блок, чтобы приложение не "падало" при проблемах с БД, а могло корректно обработать ошибку.

### Управление ресурсами (закрытие соединений)

- **Что это:** Обязательное закрытие объектов курсора и соединения после завершения операции с базой данных.
- **Почему это важно:**
  - **Избежать утечек ресурсов:** Открытые соединения потребляют память и другие ресурсы на сервере MySQL. Если их не закрывать, сервер может перегрузиться.
  - **Ограничение соединений:** У MySQL есть ограничение на количество одновременных соединений. Если вы не закрываете их, вы быстро достигнете этого лимита.
- **Пример:**
  ```python
  conn = None
  cursor = None
  try:
      conn = get_db_connection()
      cursor = conn.cursor()
      # ... выполнение операций ...
  except mysql.connector.Error as err:
      # ... обработка ошибки ...
  finally:
      if cursor: # Проверяем, что курсор был создан
          cursor.close()
      if conn: # Проверяем, что соединение было установлено
          conn.close()
  ```
- **Наше использование:** Всегда используйте блок `finally` в ваших функциях `database.py`, чтобы гарантировать закрытие курсора и соединения, независимо от того, произошла ошибка или нет.

### `python-dotenv`

- **Что это:** Простая библиотека Python для загрузки переменных окружения из файла `.env` в системные переменные окружения.
- **Пример установки:**
  ```bash
  pip install python-dotenv
  ```
- **Пример использования:**

  ```python
  # В начале вашего скрипта (например, app.py или database.py)
  from dotenv import load_dotenv
  import os

  load_dotenv() # Загружает переменные из .env файла

  db_user = os.getenv("MYSQL_USER")
  db_password = os.getenv("MYSQL_PASSWORD")
  # ... используйте эти переменные для подключения ...
  ```

- **Наше использование:** Позволяет безопасно хранить конфиденциальные данные (пароли к БД, ключи API) вне вашего Git-репозитория и легко загружать их в ваше Python-приложение. Файл `.env` должен быть добавлен в `.gitignore`.

## Настройка окружения

### Установка MySQL Server

- **Скачать и установить:** Загрузите MySQL Community Server с официального сайта MySQL (dev.mysql.com/downloads/mysql/). Выберите версию, подходящую для вашей операционной системы (Windows, macOS, Linux).
- **В процессе установки:**
  - Выберите "Full" или "Developer Default" для полноценной установки.
  - Обязательно установите **пароль для пользователя `root`**. Запомните его, он понадобится для подключения.
- **Дополнительно:**
  - Для удобства использования рассмотрите установку расширения MySQL Shell for VSCode. После установки, создайте новое соединение, введите имя пользователя (`root`), сохраните пароль. Затем все SQL-команды можно будет выполнять напрямую в интегрированном терминале VS Code.

### Создание базы данных и таблиц

В MySQL Shell (или через расширение VS Code) выполните следующие SQL-команды для создания вашей базы данных и ее структуры.

1.  **Создание базы данных:**
    ```sql
    CREATE DATABASE ai_chat_db;
    ```
2.  **Выбор базы данных:**
    ```sql
    USE ai_chat_db;
    ```
3.  **Создание таблицы `conversations`:**
    ```sql
    CREATE TABLE conversations (
        id INT AUTO_INCREMENT PRIMARY KEY,
        title VARCHAR(255) NOT NULL DEFAULT 'Новый диалог',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    );
    ```
4.  **Создание таблицы `messages`:**
    ```sql
    CREATE TABLE messages (
        id INT AUTO_INCREMENT PRIMARY KEY,
        conversation_id INT NOT NULL,
        sender ENUM('user', 'ai') NOT NULL,
        content TEXT NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
    );
    ```
    - **`ON DELETE CASCADE`**: Это очень важно! Оно гарантирует, что если запись из таблицы `conversations` (диалог) будет удалена, то все связанные с ней записи из таблицы `messages` (сообщения) также будут автоматически удалены.

### Проверка структуры и данных

После создания таблиц убедитесь, что все настроено правильно:

1.  **Просмотр списка таблиц в текущей БД:**
    ```sql
    SHOW TABLES;
    ```
    Вы должны увидеть `conversations` и `messages`.
2.  **Просмотр структуры таблицы (схемы):**
    ```sql
    DESCRIBE conversations;
    DESCRIBE messages;
    ```
    Это покажет столбцы, их типы данных, ограничения и ключи.
3.  **Просмотр данных в таблицах (пока их нет):**
    ```sql
    SELECT * FROM conversations;
    SELECT * FROM messages;
    ```

### Подключение Python к MySQL (кратко)

Для того чтобы ваш Python-бэкенд мог взаимодействовать с этой базой данных, ему потребуются:

- **Драйвер:** Библиотека `mysql-connector-python` (уже установлена в нашем окружении).
- **Учетные данные:** Параметры подключения (хост, пользователь, пароль, имя БД) должны храниться в файле `.env` в директории `backend/` для безопасности.
  ```
  MYSQL_HOST=localhost
  MYSQL_USER=root
  MYSQL_PASSWORD=ваш_пароль_root
  MYSQL_DB=ai_chat_db
  ```
- **Код:** Ваш Python-код будет использовать эти данные для установки соединения.

  ```python
  import mysql.connector
  import os
  from dotenv import load_dotenv

  load_dotenv() # Загружаем переменные из .env

  try:
      conn = mysql.connector.connect(
          host=os.getenv("MYSQL_HOST"),
          user=os.getenv("MYSQL_USER"),
          password=os.getenv("MYSQL_PASSWORD"),
          database=os.getenv("MYSQL_DB")
      )
      if conn.is_connected():
          print("Успешное подключение к MySQL!")
      conn.close()
  except mysql.connector.Error as err:
      print(f"Ошибка подключения: {err}")
  ```

## Подробнее про `MySQL` - что это за зверь?

MySQL — это **реляционная система управления базами данных (RDBMS)** с открытым исходным кодом. "Реляционная" означает, что данные хранятся в структурированных таблицах, которые связаны между собой.

### Основные концепции MySQL

- **База данных (Database):** Это контейнер для таблиц и других объектов (например, представлений, процедур). В вашем проекте `ai_chat_db` будет одной из таких баз данных. На одном MySQL-сервере может быть множество баз данных.
- **Таблица (Table):** Основная единица хранения данных. Таблица состоит из строк и столбцов, подобно электронной таблице. Каждая таблица предназначена для хранения данных определенного типа сущностей (например, `conversations` для диалогов, `messages` для сообщений).
- **Столбец (Column / Field):** Определяет тип данных, которые будут храниться в каждой записи (строке) таблицы. Каждый столбец имеет имя и определенный **тип данных** (например, `INT` для чисел, `VARCHAR` для текста, `TIMESTAMP` для даты/времени).
- **Строка (Row / Record):** Отдельная запись в таблице. Каждая строка содержит набор значений для каждого столбца таблицы.
- **Первичный ключ (Primary Key - PK):** Столбец (или набор столбцов), который уникально идентифицирует каждую строку в таблице. Значения первичного ключа не могут быть `NULL` и должны быть уникальными. Например, `id` в таблице `conversations`.
- **Внешний ключ (Foreign Key - FK):** Столбец (или набор столбцов) в одной таблице, который ссылается на первичный ключ в другой таблице. Внешние ключи устанавливают связи между таблицами и обеспечивают целостность данных. Например, `conversation_id` в таблице `messages` ссылается на `id` в таблице `conversations`.
- **Индекс (Index):** Специальная структура данных, которая улучшает скорость поиска данных в таблице. Первичные и внешние ключи обычно автоматически индексируются.

## Подробнее про библиотеку на python

Python сам по себе не "понимает" SQL или MySQL. Для этого ему нужен специальный **драйвер** (библиотека), который выступает в роли переводчика. В нашем случае это `mysql-connector-python`.

### Как писать функции на ней

Каждая функция в `database.py`, которая взаимодействует с базой данных, будет следовать этому общему алгоритму:

1.  **Получить соединение:** Вызвать вспомогательную функцию `get_db_connection()`. Если соединение не удалось, завершить работу функции.
    ```python
    conn = get_db_connection()
    if conn is None:
        return None # Или поднять исключение
    ```
2.  **Создать курсор:** Получить объект курсора из соединения. Для удобства получения результатов в виде словарей используйте `conn.cursor(dictionary=True)`.
    ```python
    cursor = conn.cursor(dictionary=True) # Для SELECT
    # или
    cursor = conn.cursor() # Для INSERT/UPDATE/DELETE
    ```
3.  **Блок `try-except-finally`:** Обернуть основную логику в этот блок для обработки ошибок и гарантированного закрытия ресурсов.
    ```python
    try:
        # ... подготовка SQL-запроса ...
        # ... выполнение запроса ...
        # ... обработка результатов (commit/fetch) ...
    except mysql.connector.Error as err:
        # ... обработка ошибки: вывод, откат транзакции ...
        conn.rollback() # Откат изменений при ошибке
        # ... вернуть соответствующее значение (None/False) ...
    finally:
        # ... закрытие курсора и соединения ...
        cursor.close()
        conn.close()
    ```
4.  **Подготовить SQL-запрос:** Написать SQL-строку с плейсхолдерами (`%s`) для данных.
    ```python
    sql = "INSERT INTO my_table (column1, column2) VALUES (%s, %s)"
    ```
5.  **Выполнить запрос:** Использовать `cursor.execute()`, передавая SQL и параметры.
    ```python
    cursor.execute(sql, (value1, value2)) # Для INSERT/UPDATE/DELETE
    ```
6.  **Обработать результаты:**
    - **Для `INSERT`/`UPDATE`/`DELETE`:** Вызвать `conn.commit()` для сохранения изменений. Проверить `cursor.lastrowid` (для `INSERT`) или `cursor.rowcount` (для `UPDATE`/`DELETE`).
      ```python
      conn.commit()
      return cursor.lastrowid # Для INSERT
      # return cursor.rowcount > 0 # Для UPDATE/DELETE
      ```
    - **Для `SELECT`:** Использовать `cursor.fetchall()` или `cursor.fetchone()`.
      ```python
      results = cursor.fetchall()
      return results
      ```
7.  **Закрыть ресурсы:** В блоке `finally` закрыть `cursor` и `conn`.

### Процесс взаимодействия:

1.  **Установка драйвера:** Вы устанавливаете `mysql-connector-python` через `pip`.
2.  **Установление соединения:** Ваш Python-код использует функции драйвера для установления сетевого соединения с MySQL-сервером, передавая ему учетные данные (хост, пользователь, пароль, имя базы данных).
    - Это создает объект **соединения (connection object)** в Python.
3.  **Создание курсора:** Из объекта соединения вы создаете объект **курсора (cursor object)**. Курсор — это абстракция, которая позволяет выполнять SQL-команды и получать результаты.
4.  **Отправка SQL-команд:** Вы вызываете метод `execute()` на объекте курсора, передавая ему строку с SQL-запросом.
    - **Важно:** Для вставки или обновления данных, которые приходят от пользователя, всегда используйте **параметризованные запросы** (с плейсхолдерами, например `%s` для `mysql-connector-python`). Драйвер сам безопасно подставит значения, предотвращая SQL-инъекции.
    ```python
    # Пример (не полный код, только для иллюстрации)
    cursor.execute("INSERT INTO messages (conversation_id, sender, content) VALUES (%s, %s, %s)", (conv_id, 'user', user_text))
    ```
5.  **Сохранение изменений (`commit`):** Если вы выполняли команды `INSERT`, `UPDATE` или `DELETE`, которые изменяют данные, вам нужно явно вызвать метод `commit()` на объекте **соединения**. Это сохраняет изменения в базе данных. Если вы забудете `commit()`, изменения не будут сохранены.
6.  **Получение результатов (`fetch`):** Если вы выполняли `SELECT` запрос, вы используете методы курсора, такие как `fetchone()` (получить одну строку) или `fetchall()` (получить все строки), чтобы извлечь результаты из MySQL в Python-объекты (например, списки кортежей или словарей).
7.  **Закрытие ресурсов:** После завершения работы с базой данных, вы должны закрыть и курсор, и соединение, чтобы освободить ресурсы на сервере MySQL.

Таким образом, Python-модуль, который мы обсуждали ранее (`database.py`), — это просто набор функций, которые инкапсулируют эти шаги (установление соединения, создание курсора, выполнение SQL, коммит/фетч, закрытие) для каждой конкретной операции с вашей базой данных.

### Сам драйвер `mysql-connector-python`

- **Что это:** Официальная библиотека Python для подключения к MySQL. Она предоставляет API (набор классов и методов), который позволяет вашему Python-коду "разговаривать" с MySQL-сервером.
- **Наше использование:** Это основа всего взаимодействия. Все функции в вашем `database.py` будут использовать этот драйвер.
